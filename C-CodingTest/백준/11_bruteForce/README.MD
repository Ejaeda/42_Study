## 📝 [2_2231.c]()- 왜 안되는지 체크할 것
### [분해합](https://www.acmicpc.net/problem/2231)
<img width="658" alt="스크린샷 2021-11-22 오후 4 05 41" src="https://user-images.githubusercontent.com/87407504/142818178-751dcc87-1f03-42e6-a7b7-8d5b81b6cdcb.png"><br>
* 핵심
```
216을 입력하면 198 + 1 + 9 + 8 을 만족하는 198을 출력
```
* 문제접근
```
1.
시간제한이 2초이기 때문에 범위 신경쓰지않고 1000000번을 돌려도 문제가 없지만
범위를 고려해보자
2.
돌려서 값이 있는지 확인하는 방법으로 %10을 하고
그 값을 sum에 누적하여 각각의 자릿수 값을 더해주고 /10한 값을 돌리자
3.
돌려서 값이 없으면 0을 출력
```
* 아이디어
```
1.
123에 맞는 값을 찾기 위해서 1부터 찾을 필요가 없다
3자리 숫자의 최대 값은 999 + 9 + 9 + 9 이므로
입력값 - 9*자릿수 로 초기값을 설정할 수 있다
예를들어 127의 입력값은 127 - 9*3에 해당하는 100부터 찾는것이 맞다
99일 경우 99 + 9 + 9로 당연히 127이 될 수 없는 숫자이다
```
* 코드구현
```.c
1.
//초기값을 설정하기 위한 자릿수 check
#include <stdio.h>

int main(){
    int idx2 = 0, sum = 0, cnt = 0, tmp = 0, N, check;
    scanf("%d", &N);
    check = N;

    while(check){
        check /= 10;
        cnt++;
    }
    for(int idx = N - 9*cnt; idx <= N; idx++){
        sum = 0;
        tmp = idx;
        idx2 = idx;
2.
        while(idx2){
            sum += idx2 % 10;
            idx2 /= 10;
        }
        sum += tmp;
        if(N == sum){
            printf("%d\n", idx);
            return 0;
        }
    }
3.
    printf("0\n");
    return 0;
}
```
* 정리
```.c
while(idx)로 설정하는 바람에 idx++값에 0이 전달되어 무한루프를 돌았다
잘 고려하자
```
## 📝 [3_7568.c](https://github.com/Ejaeda/Coding_Test/blob/master/%EB%B0%B1%EC%A4%80/11_BruteForce/03_7568.c)
### [덩치](https://www.acmicpc.net/problem/7568)
<img width="707" alt="스크린샷 2021-12-06 오후 1 59 40" src="https://user-images.githubusercontent.com/87407504/144789832-89de77c9-41d4-4f88-a49f-9daebf6d103a.png"><br>

-  핵심
```.c
키와 몸무게 둘다 커야 덩치가 크다
키 공백 몸무게 순으로 입력받는다
```

-  문제접근
```.c
1. 입력방식
횟수를 입력받고 횟수값만큼 반복문을 돌린다
키와 몸무게를 같이 비교해야 하므로 이차원 배열로도 가능하고
키, 몸무게 각각의 배열을 설정하고 각각 같은 인덱스에 저장

2. 비교방식
출력 방식을 어떻게 할 것인지 고민해보자
출력은 키 몸무게가 둘다 클 경우 순위로 매겨져 순위가 출력된다
1차원적으로 생각했을 때 키배열에서 큰 순서대로 비교 후 인덱스 값을 저장 후
큰 순서대로 인덱스 값을 불러와 인덱스 값 고정 후 
몸무게배열값들과 비교
키가 가장큰 인덱스 idx 고정하고 몸무게와 비교 시
1) [idx] < 발생 시 공동 등치가 있다는 것
1로 출력하고 두번째 키큰순서로 이동
2) [idx] < 경우에 공동 1등 후 다음 키 큰순 이동
3) [idx] > 경우에 공동 1등 후 1++ 해주고 다음 키 큰순 이동

문제점)
키큰 순서대로 idx값을 가져오기 위해서는 idx결과 값들을 담아야하는 문제가 있음
```
-  아이디어
```.c
큰 순서대로 접근하지 않고 키와 몸무게 둘다 작은 경우를 생각해보자
idx = i인 경우 j와 비교시 키와 몸무게 둘다 i보다 클 경우 순위++을 돌리는 반복문설정
이중 for문 한번으로 단순 출력이 가능
```

-  함수구현
```.c
1.
#include <stdio.h>

int main(){
    int turn = 0, rank;
    int w[50] = {0}, l[50] = {0};
    scanf("%d", &turn);
// 입력
    for(int idx = 0; idx < turn; idx++){
        scanf("%d %d", &w[idx], &l[idx]);
    }
2.
    for(int i = 0; i < turn; i++){
        rank  = 0;
        for(int j = 0; j < turn; j++){
            if(w[i] < w[j] && l[i] < l[j])  rank++;
        }
    printf("%d ", rank+1);
    }
    return 0;
}
```

-  새로 배운점
```.c
문제에서 입력관련 기술에서 헷갈렷던 점은 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다고 한점에 대해
공백은 저장되지 않는다 그냥 printf("%d %d", &x, &y)하면 된다

키와 몸무게 둘다 큰 순서순으로 나열하는 방식에서 둘다 작을 때마다 카운트를 하나씩 올려주는 아이디어 
```




## 📝 [5_1436.c]()
### [영화감독 숌](https://www.acmicpc.net/problem/1436)
<img width="682" alt="스크린샷 2021-11-24 오후 6 56 04" src="https://user-images.githubusercontent.com/87407504/143216032-90138716-64e5-4a96-9147-276ed7300f11.png"><br>
* 핵심
```
입력되는 숫자 N은 666이 포함된 숫자 중 몇번째 숫자인지를 가리킨다
숫자를 하나씩 올려주면서 666이 있을때마다 cnt를 해주고 N과 동일할 경우 해당 숫자를 출력하면 된다
```
* 문제접근
```
1. 가장먼저 나오는 숫자는 666이므로 시작순서를 1로 할 필요 없이 더해질 1을 포함한 665로 시작한다
2. 1000으로 나눈 나머지가 666인지를 보고 판단할 수 있다
3. 백, 십, 일의자리가 666이 아니고 천, 백, 십의자리가 666일 경우 어떻게 한 자리수 씩 올라갈 수 있을까?
```
* 아이디어
```.c
3. num / (int)pow(10, idx) % 1000 == 666 을 통해 가능하다
idx가 0부터 시작하여 for문으로 하나씩 올려주면 일의자리를 빼주면서 체크가 가능하다
최대 N이 가질 수 있는 숫자는 10,000이므로 이에 해당하는 숫자는 2666799이므로
idx가 3까지만 올라가도 충분하다
```
* 코드구현
```.c
1.
#include <stdio.h>
#include <math.h>

int main(){
    int N, cnt = 0, num = 665;
    scanf("%d", &N);

    while(1){
        if(cnt == N){
            printf("%d", num);
            return 0;
        }
        num++;
2. 3.
        for(int idx = 0; idx < 4; idx++){
            if(num /(int)pow(10, idx) % 1000 == 666){
                cnt++;
                break;
            }
        }
    }
}
```
-  심화학습

[`strstr`](https://github.com/Ejaeda/42_study/blob/master/C/C_Reference/string.h/strstr.MD),
[`sprint`]()
```.c
#include <stdio.h>
#include <string.h>

int main() {
    int input;
    scanf("%d", &input);
    int value = 666;

    for(int idx = 0; idx != input; value++){
        char str[8];
        sprintf(str, "%d", value);
        if (strstr(str, "666") != NULL)
            idx++;
    }
    --value;
    printf("%d\n", value);

  return 0;
}
```

# [체스판 다시 칠하기]()
## [1018]()

-  핵심

```
검 흰 이 반복되는 체스보드를 만든다
최소 8*8 사이즈부터 50*50 사이즈의 재료에서 보드를 만든다
입력받은 사이즈에서 수정해야하는 곳이 최소인 구역을 찾아야한다
출력값으로 최소 수정해야하는 개수를 구하는 프로그램을 만든다
```
-  문제접근

```
1.
N*M의 문자들을 우선 받아 저장할 공간이 필요하다
2.
저장 공간 중에서 8*8을 어떻게 추릴지 고민해야한다
3.
해당 자리가 검의 자리인지 흰의 자리인지 판단할 수 있어야한다
4.
판단하는 경우의 수는 두가지이다 첫번째 자리가 검인지 흰인지
```
-  아이디어

```.c
3.
이중 for문을 돌리고
if((idx + idx2) % 2 == chess[idx][idx2]) cnt1++;
if((idx + idx2 + 1) % 2 == chess[idx][idx2] cnt2++;
각각의 인덱스의 합이 가지는 의미를 생각해보자
```

|배열의|인덱스|예시|
|:---:|:---:|:---:|
|(0,0)|(0,1)|(0,2)|
|(1,0)|(1,1)|(1,2)|
|(2,0)|(2,1)|(2,2)|

|배열의|인덱스|합의값|
|:---:|:---:|:---:|
|0|1|2|
|1|2|3|
|2|3|4|

체스판과 같이 값들이 짝수, 홀수 번갈아 나온다
```.c
첫 값 0,0 이 들어왔다고 생각했을때
if                 // 1. 탐색선을 시작하는 첫번째 블록이 흰색일 때
(0 + 0) % 2        // 3. 0 즉 검은색이면
== chess[0][0]     // 2. 첫번째 시작하는 자리에
cnt1++;            // 4. 바꿔야한다는 체크++
 
if                 // 1. 탐색선을 시작하는 첫번째 블록이 검은색일 때
(0 + 0 + 1) % 2    // 3. 1 즉 흰색이면
== chess[0][0]     // 2. 첫번째 시작하는 자리에
cnt2++;            // 4. 바꿔야한다는 체크++
```

