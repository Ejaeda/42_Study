# :grey_exclamation: 추상 자료형: Abstract Data Type
### 자료구조에서의 추상 자료형(ADT)
-   정의

    구체적인 완성과정을 언급하지 않고, 순수하게 `기능이 무엇인지를 나열한 것`
    
-   자료형의 정의
    
    구조체를 정의하는 것 뿐만 아니라 해당 구조체를 기반으로 한 **연산**의 종류를 결정하는 것까지 포함
    (해당 구조체를 기반으로 제공할 수 있는 기능 관련 연산)

    다시말해  **자료형**의 정의에 **기능**(연산)과 관련된 내용을 명시할 수 있음

##### 예시
-   구조체 Wallet과 Wallet의 ADT
```.c
typedef struct_wallet  // 동전 및 지폐 일부만을 대상으로 표현한 지갑
{
    int coin100Num;     // 100원짜리 동전의 수
    int bill5000Num;    // 5,000원짜리 지폐의 수
} Wallet;
```
> 구조체 선언
```.c
int   TakeOutMoney(Wallet* pw, int coinNum, int billNum) // 돈을 꺼내는 연산
void  PutMoney(Wallet* pw, int coinNum, int billNum)     // 돈을 넣는 연산
```
> 기능을 명시

# :grey_exclamation: 배열을 이용한 리스트 구현
> 리스트는 연결 리스트와 다름 by 구현방법차이

### 리스트의 이해
-   순차 리스트

    배열을 기반으로 구현된 리스트
-   연결 리스트

    메모리의 동적 할당을 기반으로 구현된 리스트
    
-   리스트 자료구조의 특성

    `데이터를 나란히 저장`<br>
    `중복된 데이터의 저장을 막지않음`
    
### 리스트의 ADT
> 리스트 자료구조가 제공해야할 기능들

`void ListInit(List* plist);`

-   초기화할 리스트의 주소 값을 인자로 전달
-   리스트 생성 후 제일먼저 호출되어야 하는 함수

`void LInsert(List* plist, LData data);`

-   리스트에 데이터를 저장
-   매개변수 data에 전달된 값을 저장

`int LFirst(List* plist, LData* pdata);`

-   첫번째 데이터가 pdata가 가리키는 메모리에 저장
-   데이터 참조를 위한 초기화 진행
-   성공 시 TRUE(1), 실패 시 FALSE(0) 반환

`LData LRemove(List* plist);`

-   LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
-   삭제된 데이터를 반환
-   마지막 반환 데이터를 삭제하므로 연이은 반복호출을 허용하지 않음

`int LCount(List\* plist);`

-   리스트에 저장되어 있는 데이터의 수를 반환


### 리스트의 ADT를 기반으로 정의된 main 함수
[ListMain.c]()

-   LFirst와 LNext

    리스트 내에서 데이터의 참조위치를 기록함
    
    따라서 처음부터 참조를 새롭게 시작하기 위해서는 데이터 참조위치를 초기화 해야함
    
    이를 위해 `LFirst`를 호출
    
    `LNext`함수 호출을 통해 다음에 저장된 데이터를 이어서 획득

> 모든 데이터의 참조 : LFirst → LNext → LNext → LNext ...

-   LRemove

    삭제를 위해서는 탐색이 선행어야 함
    
    `LRemove`가 호출되면, 직전에 참조된 데이터가 삭제됨

### 배열 기반으로 리스트 구현하기: ArrayList.h
[ArrayList.h]()

##### 구조체 ArrayList

```.c
#ifndef __ARRAY_LIST_H__
#define __ARRAY_LIST_H__

#define TRUE	1
#define FALSE	0

#define LIST_LEN	100
typedef int LData;	 		    // int형 데이터의 저장을 위한 선언

typedef struct __ArrayList
{
	LData arr[LIST_LEN];                // 데이터의 저장공간이 배열로 선언
	int numOfData;                      // 저장된 데이터의 수
	int curPosition;                    // 데이터 참조위치 기록
} ArrayList;

typedef ArrayList List;       	  	    // List는 배열 기반 리스트임을 선언

void ListInit(List * plist);           	    // 초기화
void LInsert(List * plist, LData data);     // 데이터를 저장

int LFirst(List * plist, LData * pdata);    // 첫 데이터 참조
int LNext(List * plist, LData * pdata);     // 두번째 이후 데이터 참조

LData LRemove(List * plist);                // 참조한 데이터 삭제
int LCount(List * plist);                   // 저장된 데이터 수 반환

#endif
```

### 삽입과 조회

-   `ListInit(List* Plist)` 초기화 작업 

```.c
void	ListInit(List* Plist){
	(plist -> numOfData) = 0;	    // 리스트에 저장된 데이터의 수는 0
	(plist -> curPosition) = -1; 	    // 현재 아무 위치도 가리키지 않는다는 뜻
}
```

`curPosition` 배열의 인덱스 값이 저장

이 값을 통해서 LFirst와 LNext가 참조해야할 배열의 위치를 알 수 있으므로 curPosition은 -1로 초기화

-   `void LInsert(List* plist, LData data)` 데이터의 수가 배열의 길이를 초과했는지 검사

```.c
void	LInsert(List * plist, LData data) {
    if	(plist->numOfData >= LIST_LEN) {.   // 더 이상 저장할 공간이 없다면
        puts("저장이 불가능합니다.");
        return;
    }
 
    plist->arr[plist->numOfData] = data;    // 데이터 저장
    (plist->numOfData)++;		    // 저장된 데이터의 수 증가
}
```

-   `int LFirst(List * plist, LData * pdata)` `int LNext(List * plist, LData * pdata)` 조회

```.c
int LFirst(List * plist, LData * pdata) {
    if (plist->numOfData == 0)		    // 저장된 데이터가 하나도 없다면
        return FALSE;
 
    (plist->curPosition) = 0;		    // 참조위치 초기화(첫 번째 데이터의 참조를 의미)
    *pdata = plist->arr[0];		    // pdate가 가리키는 공간에 데이터 저장
    return TRUE;
}
 
int LNext(List * plist, LData * pdata) {
    if (plist->curPosition >= (plist->numOfData) - 1)
        return FALSE;			    // 더 이상 참조할 데이터가 없다면
 
    (plist->curPosition)++;
    *pdata = plist->arr[plist->curPosition];
    return TRUE;
}
```
> ☑️ `LFirst : (plist -> curPosition)=0;`
> curPosition에 저장된 값을 0으로 재설정하여 데이터의 참조가 앞에서부터 다시 진행되게 한다
> ☑️ `LNext : (plist->curPosition)++;`
> curPosition 값을 증가시켜 순서대로 데이터를 참조할 수 있도록 한다

### 삭제

- `LData LRemove(List* plist)`

```.c
if (LFirst(&list, &data))
{
    if (data == 22)  
        LRemove(&list);			    // 앞서 LFirst함수가 참조한 데이터 삭제
	
    while(LNext(&list, &data))
    {
        if (data == 22)
            LRemove(&list); 		    // 앞서 LNext함수가 참조한 데이터 삭제
    }
}
```
> `LRemove`함수는 `LFirst`함수나 `LNext`함수의 호출을 통해 바로 직전에 참조가 이뤄진 데이터를 삭제한다<br>
<img width="352" alt="스크린샷 2021-11-23 오후 8 39 38" src="https://user-images.githubusercontent.com/87407504/143017864-e4c4a4ed-b842-4a2f-9ed7-60bd40757856.png"><br>
> `LRemove`함수가 호출되면 리스트의 멤버 `curPosition`을 확인해서, 조회가 이뤄진 데이터의 위치를 확인한 후에, 그 데이터를 삭제한다
> 중간에 데이터가 삭제되면, 뒤에 저장된 데이터를 한 칸씩 앞으로 이동시켜 빈 공간을 메워야 한다


