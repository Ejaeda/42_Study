# :grey_exclamation: 함수의 재귀적 호출의 이해
### 재귀
```
재귀함수를 연속적으로 호출하면 기존에 작동하던 재귀함수는 스택(stack)에 쌓이고 호출된 재귀함수가 먼저 작동
처음 불려진 함수에서(스택 맨 밑에있는 메소드) returm 되는 값이 최종 return 값
```

### Factorial 재귀함수
* 함수 구현
```
1. 정수 n 팩토리얼은 n * (n - 1)!
2. 0! = 1 (예외처리)
```
* 코드
```.c
#include <stdio.h>
int Factorial(int n)
{
  if(n == 0)
    return 1;
  else
    return n * factorial(n - 1);
}
```
* 동작 방식
```
fact(3)이 동작되는 방식

1. n !=0 이므로 fact(2)를 호출
fact(3)은 stack에 쌓인채로 fact(2)이 실행
```
|stack|
|:---:|
|fact(3)|

```
2. n !=0 이므로 fact(1)를 호출
fact(2)는 stack에 쌓인채로 fact(1)이 실행
```
|stack|
|:---:|
|fact(2)|
|fact(3)|
```
3. n !=0 이므로 fact(0)를 호출
fact(1)은 stack에 쌓인채로 fact(0)이 실행
```
|stack|
|:---:|
|fact(1)|
|fact(2)|
|fact(3)|
```
4. n == 0 이므로 return 0
끝가지 갔다면 역으로 올라오면서 return값 fact(1) 부터 차례로 받아오기
마지막 return은 첫 fact(3)에 해당되는 return
```
### Fibonacci 재귀함수
* 함수 구현
```
1. 정수 n 피보나치는 n-1 + (n - 2)
2. fibo(1) = 0 (예외처리)
3. fibo(2) = 1 (예외처리)
```
* 코드
```.c
#include <stdio.h>
int fibo(int n)
{
    if(n == 1)
        return 0;
    else if(n == 2)
        return 1;
    else
        return fibo(n-1) + fibo(n-2);
}
```
<img width="556" alt="스크린샷 2021-11-19 오후 8 58 30" src="https://user-images.githubusercontent.com/87407504/142619304-f1a69bf7-bad4-4943-afda-b064e1d1735f.png"><br>
### binary 재귀함수
* 함수 구현
```
1. 탐색 범위의 중앙에 목표값이 저장되었는지 확인
2. 저장되지 않았다면 탐색 범위를 반을 줄여서 다시 탐색시작(재귀)
```
* 코드
```.c
int Bsearch(int arr[], int first, int last, int target)
{
    int mid;
    if(first > last)              // 끝까지 못 찾았을 경우 종료조건, 탐색 실패 경우의 예외처리
        return -1;
        
    mid = (first + last) / 2;
    if(arr[mid] == target)        // 찾았을 경우
        return mid;
```
```
함수 구현에 기재된 재귀의 활용
```
```
    else if(target > arr[mid])
        Bsearch(arr, mid + 1, last, target);
        // 기존의 방식 first = mid + 1
    else
        Bsearch(arr, first, mid - 1, target);
        // 기존의 방식 last = mid - 1
}
```
### 하노이 타워
<img width="662" alt="스크린샷 2021-11-19 오후 9 14 57" src="https://user-images.githubusercontent.com/87407504/142621272-2a4414b6-6afa-4fab-90f2-09a0d7f34b25.png"><br>
* 함수구현
```
1. 작은 원반 n-1개를 A에서 B로 이동
2. 큰 원반 1개를 A에서 C로 이동
3. 작은 원반 n-1개를 B에서 C로 이동
```
> 재귀함수의 연속
* 코드
```
void Hanoi(int num, char from, char by, char to)
{
```
```
맨 마지막에 남는 원반은 그냥 이동하면 된다
```
```
    if(num == )                   // 이동할 원반의 수가 1개일 떼
        printf("원반1을 %c에서 %c로 이동 \n", from ,to);
```
```
첫번째 이동하는 원반은 A에서 B로 이동한다
```
    else
        Hanoi(n-1, from, to, by)
```
```

```
