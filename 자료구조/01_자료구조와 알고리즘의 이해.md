# 자료구조에 대한 기본적인 이해
## :grey_exclamation: 자료구조
프로그램은 데이터를 표현하고 그렇게 표현된 데이터를 처리하는 것이라 말하는데, 여기서 데이터를 표현 즉 저장을 담당하는 것이 자료 구조<br>
데이터에 편리하게 접근하고, 변경하기 위해서 데이터를 저장하거나 조직하는 방법<br>
쉬운 데이터 저장 방법의 예로, 정수를 저장하기 위해 
 * int형 변수를 선언<br>
 * 개인정보를 저장하기 위해 구조체를 정의<br>

## :grey_exclamation: 자료구조의 분류
<img width="710" alt="스크린샷 2021-11-17 오후 3 14 18" src="https://user-images.githubusercontent.com/87407504/142144988-b5c163a3-acef-400b-8b76-12ac66717fdc.png"><br>
### :white_small_square: 선형 자료구조 :<br>
 <img width="250" alt="스크린샷 2021-11-17 오전 11 35 32" src="https://user-images.githubusercontent.com/87407504/142110369-a4da5550-2805-4ff4-a18d-77bf8498b06d.png"><br>
 * 자료를 선형(linear)으로 표현 및 저장하는 방식
 * 하나의 자료 뒤에 하나의 자료가 존재하는 것
 * 배열과 리스트가 대표적이고 더 나아가 스택, 큐
### :white_small_square: 비선형 자료구조 :<br>
 <img width="150" alt="스크린샷 2021-11-17 오전 11 35 48" src="https://user-images.githubusercontent.com/87407504/142110576-fda69293-ebb5-49ed-b025-387d9deb74c2.png"><br>
 * 하나의 자료뒤에 여러개의 자료가 존재할 수 있는 것
 * 대표적으로 트리와 그래프
## :grey_exclamation: 자료구조와 알고리즘
### :white_small_square: 자료구조
```
int idx, sum;
int arr[10] = {1, 2, ,3, 4, 5, 6, 7, 8, 9, 10}
```
### :white_small_square: 알고리즘
```
for(idx = 0; idx < 10; idx++)
    sum += arr[idx];
```
자료구조에 따라 알고리즘이 달라진다(알고리즘은 자료구조에 의존적)

# 알고리즘의 성능분석 방법
## :grey_exclamation: 알고리즘을 평가하는 요소
속도(시간 복잡도), 메모리사용량(공간 복잡도)<br>
### :white_small_square: 시간 복잡도
메모리 사용량보다 속도에 더 초점을 맞춘다<br>
수행 속도를 평가하는 방법 :<br>
:heavy_check_mark: 연산의 횟수를 센다<br>
:heavy_check_mark: 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 구성한다<br>
  * 방식<br>
<img width="304" alt="스크린샷 2021-11-17 오후 1 46 35" src="https://user-images.githubusercontent.com/87407504/142136486-0baaeec7-0b6f-4e33-8cea-e9e91a391b5f.png"><br>
데이터가 충분히 많은 것을 고려했을 때 알고리즘 A가 더 좋은 알고리즘이다<br>
데이터의 수가 많지 않고 성능에 덜 민감한 경우 알고리즘 B를 선택하기도 한다<br>
:heavy_check_mark: 상황에 맞게 판단해야한다<br>
## :grey_exclamation: 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석의 핵심요소
* 순차 탐색 알고리즘이 적용된 코드
```
#include <stdio.h>
// 배열의 내용을 왼쪽에서 오른쪽으로 이동시키며 순차적으로 target을 탐색
int    LS(int ar[], int len, int target)
{
    for(int idx = 0; idx < len, idx++)
    {
        if(ar[idx] == target)
            return idx;
    }
    return -1;
}
int    main()
{
    int    arr[] = {3, 5, 7, 9};
    int    idx;
    //int형 배열이므로 배열의 크기를 string으로 구할 수 없다
    //sizeof를 이용하여 int형 배열의 크기를 구한다
    idx = LS(arr, sizeof(arr)/sizeof(int), 7);
    if (idx == -1)
        printf("탐색 실패\n");
    else
        printf("타겟 저장 인덱스: %d\n", idx);

    return 0;
}
```
:heavy_check_mark: 연산 횟수를 센다
  * 사용된 연산자 : (<, ++, ==)
  * 핵심이 되는 연산자 : 동등 비교 연산자(++) //(<, ++)는 (==)에 의존
  * 핵심이 되는 연산자를 판단했다면 이를 중심으로 시간 복잡도를 계산<br>

:heavy_check_mark: 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 구성한다<br>
  * 시간 복잡도의 계산은 최악의 경우를 기준으로 계산(target이 맨 마지막에 나올 경우로 계산)<br>
  * 순차 알고리즘의 데이터 수 n에 대한 연산횟수의 함수 = T(n)<br>
## :grey_exclamation: 이진 탐색 알고리즘
* 방식
  * 배열 인덱스의 시작(first)과 끝(last)을 기준으로 mid idx를 비교대상(target)으로 선택한다
  * case1 : mid idx > target 경우 last = mid - 1
  * case2 : mid idx < target 경우 first mid + 1
  * 같을 때 까지 반복한다
  * first > end가 되면 탐색을 실패하고 종료한다
* 이진 탐색 알고리즘이 적용된 코드(모든 값이 정렬되었다는 조건 필요)
```
#include <stdio.h>
int     BS(int ar[], int len, int target)
{
    int     first = 0;
    int     last = len - 1;
    int     mid;

    while(first <= last)
    {
        mid = (first + last) / 2;

        if(target == ar[mid])
            return(mid);
        else
        {
            if(target > ar[mid])
                first = mid + 1;
            else
                last = mid - 1;
        }
    }
    return -1;
}

int     main()
{
    int     arr[] = {1, 3, 5, 7, 9};
    int     idx;
    //int형 배열이므로 배열의 크기를 string으로 구할 수 없다
    //sizeof를 이용하여 int형 배열의 크기를 구한다
    idx = BS(arr, sizeof(arr)/sizeof(int), 7);
    if(idx == -1)
        printf("탐색 실패\n");
    else
        printf("타겟 저장 인덱스: %d\n", idx);

    return 0;
}

```
:heavy_check_mark: 연산 횟수를 센다
  * 핵심이 되는 연산자 : 동등 비교 연산자(++)<br>

:heavy_check_mark: 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 구성한다<br>
  * 최악의 경우: n이 1이 될 때까지 2로 나눈 후 남은 1을 비교하기 위해 추가 1회 연산
  * 위 글을 식으로 표현 : 
  <br><img width="100" alt="스크린샷 2021-11-17 오후 2 29 47" src="https://user-images.githubusercontent.com/87407504/142140586-64ec34b4-031a-4b7b-b8cd-e7c8739c8d23.png"><br>
  * 횟수를 말하는 k를 기준으로 식 수정 : 
  <br><img width="400" alt="스크린샷 2021-11-17 오후 2 29 53" src="https://user-images.githubusercontent.com/87407504/142140698-0ecb5197-d95f-4aba-a817-64cac012874e.png">
  * 시간복잡도 T(n): 
  <br><img width="200" alt="스크린샷 2021-11-17 오후 2 30 00" src="https://user-images.githubusercontent.com/87407504/142140854-5b801b29-2ca9-4a03-a4cf-6fd2a7cda6cd.png">
  * T(n)는 수의 증가에 따른 연산횟수의 변화 정도에 주목하므로 + 1은 의미가 없다(빅-오 표기법을 살펴보자)
 ## :grey_exclamation: 빅-오 표기법
 * 시간 복잡도를 계산할 때 중요한 것은 정확한 값이 아닌 연산횟수에 따른 변화 정도이다
 * 변화에 영향이 크지 않은 것들은 모두 배제하고 최고차항의 차수만 가진다
 * 빅-오 그래프 :
 <br><img width="402" alt="스크린샷 2021-11-17 오후 2 40 56" src="https://user-images.githubusercontent.com/87407504/142141526-d59dc73e-463a-4bd3-93f0-9148a1281593.png">
 * 빅-오의 크기 :
 <br><img width="507" alt="스크린샷 2021-11-17 오후 2 44 06" src="https://user-images.githubusercontent.com/87407504/142141814-e94f1996-b7a8-49e1-9c32-adb38992fcf9.png">
 * 즉, n^n에 가까울수록(그래프가 위로 올라갈수록) 성능은 떨어지고, 1에 가까울수록(그래프가 내려갈수록)성능은 올라간다

### :pencil2: 빅-오에 대한 수학적 접근<br>
![KakaoTalk_Photo_2021-11-17-15-11-09](https://user-images.githubusercontent.com/87407504/142144617-4c4d2f4a-9490-4b44-929f-a5ae47ede234.jpeg)
