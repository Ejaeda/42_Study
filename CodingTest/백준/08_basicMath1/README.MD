## :pencil: [4_2869.c](https://github.com/Ejaeda/Coding_Test/blob/master/백준/Step08_기본수학1/4_2869.c)
### [달팽이는 올라가고 싶다](https://www.acmicpc.net/problem/2869)<br>
<img width="692" alt="스크린샷 2021-11-19 오후 1 56 56" src="https://user-images.githubusercontent.com/87407504/142567306-b19ee1c5-542c-43a7-99de-978a87abc82c.png"><br>
* 핵심
```
시간 제한 0.15초
1 <= B < A <= V <= 1,000,000,000
일반적인 코드로 입력단위가 억 단위로 들어오면 0.15초 연산이 불가능
```
* 문제접근
```
1. 정상에 도달하지 못한다면 달팽이는 A - B를 이동
2. 낮에 남은 거리가 V - A라면 낮에 무조건 정상도착
3. V - A 거리를 1번의 식으로 나누면 도달 시간을 구할 수 있고 다음날 도착
```
* 코드구현
```.c
V -= A; // 전체거리 V에서 A의 거리를 한번 빼주기
day = V / (A - B); // A를 뺀 거리를 낮과 밤을 반복해서 갈 경우 걸리는 시간 day
day++; // 남은 거리 A를 이동하여 정상으로 도달하는 날 +1;
if (V % (A - B) != 0)
    day++;
// day를 구하는 과정에서 나머지가 발생한다면 그 나머지만큼 마지막 거리 A에 더해지므로
// A 한번만에 도달할 수 없게 되므로 추가적으로 하루를 추가하는 예외처리
```
* 정리
```
예외처리에 능동적으로 대처하기
나머지가 발생한다는 것은 하루 더 지나서 도달한다는 느낌 잘 가져가고 응용할 수 있도록 
```

## :pencil: [6_2755.c](https://github.com/Ejaeda/Coding_Test/blob/master/백준/Step08_기본수학1/6_2775.c)
### [부녀회장이 될테야](https://www.acmicpc.net/problem/2775)<br>
<img width="586" alt="스크린샷 2021-11-19 오후 3 00 34" src="https://user-images.githubusercontent.com/87407504/142573048-05831d68-5187-4d17-bc33-0af558b2d835.png"><br>
* 핵심
```
아파트는 0층부터 14층까지
아파트는 1호부터 14호까지
a층의 b호 사람들 수는 a-1층의 1호부터 b호까지 사람들의 합
k층의 n호 거주인원을 출력
```
* 문제접근
```
1. 0층부터 14층까지, 그리고 1호부터 14호까지 이므로 이차원배열을 선언
2. 이차원 배열에 각 호마다의 사람들 수를 기재
입력된 층의 호수를 저장되어있는 데이터에서 가져와서 출력하자
```
* 아이디어
```
a층의 b호 사람들 수는 a-1층의 1호부터 b호까지 사람들의 합
-> a층의 b호 사람들 수는 a-1층의 b호 사람들 수 + a층의 b-1호 사람들 수  
// 아이디어 잘 기억하자 무식하게 재귀를 사용하려고 했다
```
* 코드구현
```.c
1. 
0층부터 14층까지, 그리고 1호부터 14호까지 이므로 
int apt[15][15]; // int를 char라고 해서 틀렸다 제대로 생각하자
2. 
아이디어를 활용하려면 먼저 0층의 데이터가 우선 기재 되어야 한다
for(idx = 0; idx < 15; idx++)
		apt[0][idx] = idx;
3. 
각 층의 0호는 없으므로 애초에 배열의 각 값을 0으로 초기화하면 0호의 값을 넣을 필요가 없다
4. 
a층의 b호 사람들 수는 a-1층의 b호 사람들 수 + a층의 b-1호 사람들 수
for(idx = 1; idx < 15; idx++)
		for(idx2 = 1; idx2 < 15; idx2++)
			apt[idx][idx2] = apt[idx-1][idx2] + apt[idx][idx2-1];
5. 
문제에서 입력값을 첫번째줄 두번째줄 이라는 말 표현을 쓰는데 \n을 고려하지 않고 그냥 같이 써도 된다
scanf("%d", &test);
scanf("%d %d", &k, &n);
```
* 정리
```
이전보다 확실히 이차원 배열을 다루는데 익숙했다는 감이 생긴다
그렇지만 문제에 대한 빠른 대처방안이 나오지 않았다
이번에 나온 아이디어 잘 기억하기
1호부터 시작되지만 0값이 들어있는 0호를 배열에서 제거하지 않고 아이디어와 연계하는 방식도 함께 기억하기
```

## :pencil: [7_2839.c](https://github.com/Ejaeda/Coding_Test/blob/master/백준/Step08_기본수학1/7_2839.c)<br>
### [설탕 배달](https://www.acmicpc.net/problem/2839)
<img width="628" alt="스크린샷 2021-11-19 오후 3 42 41" src="https://user-images.githubusercontent.com/87407504/142577223-944ff9c6-a14a-408d-8886-327eda9b3581.png"><br>
* 핵심
```
3키로보다 5키로를 더 많이 사용해야 더 적은 개수의 봉지를 배달 할 수 있음
```
* 문제접근
```
처음에는 단순하게 5키로 먼저 나눠보고 안나눠지면 3키로로 나누고 그래도 안되면 -1 출력으로 쉽게 생각했음
위와 같이 코드를 구현하면 11과 같은 예시에서 오류 발생
이를 고려한 아이디어가 필요
```
* 아이디어
```
1.
5로 먼저 나누어 보고 나누어 떨어지면 바로 몫을 출력 // 5가 3보다 우선되어야 하므로 5먼저 사용
2.
5로 나누어 떨어지지 않는다면 3을하나 써보고 다시 5로 나누어보기 // idea의 핵심
3.
이를 반복했을 때 나누어 떨어지지 않는다면 -1을 출력
```
* 코드구현
```.c
1.
while(N > 0)
	{
		if(N % 5 == 0)
		{
			try += N / 5;
			printf("%d", try);
			return 0;
		}
2.
		else
		{
			N -= 3;
			try++;
		}
3.
// 3을 빼줬는데 N >. 0을 만족하지 못하면서 printf를 하지 못한 채 나가게 되면 -1을 출력하므로 이에대한 예외처리 
		if(!N)
		{
			printf("%d", try);
			return 0;
		}
	}
	printf("-1");
	return 0;
}
```
* 정리
```
바로바로 떠오르지 않았다
5를 우선한다면 5 위주로 나눗셈을 하되 나머지가 발생할 경우 하나씩 3을 빼주면서 이를 반복하는 방법을 잘 
```

## :pencil: [8_10757.c](https://github.com/Ejaeda/Coding_Test/blob/master/백준/Step08_기본수학1/8_10757.c)<br>
### [큰 수 A + B](https://www.acmicpc.net/problem/10757)<br>
<img width="629" alt="스크린샷 2021-11-19 오후 6 46 50" src="https://user-images.githubusercontent.com/87407504/142601858-78b6cf0a-daee-45b1-b6d3-fe2a95fd8ad2.png"><br>
* 핵심
```
int형은 오버플로우 발생
```
* 문제접근
```
1. char형 문자열에 담기
2. 일상적으로 오른쪽 자릿수부터 덧셈하는 세로 덧셈 방식을 구현하기
3. 위 방식을 위해 입력받은 문자열 내용을 거꾸로 전환하는 reverse함수 만들기
4. 두 일의 자리 수가 더해져 십의자리 수가 될 경우 carry 변수를 설정해 +1 처리하기
```
* 아이디어
```
실제 덧셈 방식을 코드로 적용하는 법을 잘 기억하자
일의자리 숫자부터 더해야하니 문자열 특성상 거꾸로 뒤집어야하고
char형 문자열을 한꺼번에 int형 문자열로 바꿀생각을 하지말고
한번 더할때마다 int형 변수에 담아 -'0'을 해주면 char이 int형으로 표현 변경 가능
1. char형으로 입력받고 
2. reverse 해주고 
3. 일의 자리씩 더해주고 
4. int형 변수에 값을 넣을때 -'0'해주고 
5. 십의자리가 발생할 경우 carry 예외처리로 추가로 더해주고 
6. carry처리 된 결과 값을 +'0' 하여 char res에 다시 넣어주기 넣을때 carry인 1을 더해주는건 다음 회차에 더해질테니 sum % 10 값만 넣기 
7. 마지막 carry추가를 해야하는데 그게 처리가 안된 상태로 for문을 나오니 예외처리 추가로 더해주기
8. 거꾸로 입력된 결과값을 reverse 함수를 통해 다시 전환 
9. 문자열 출력
```
* 함수구현
```.c
1.
char A[10001] = {0, }, B[10001] = {0, }, res[10002] = {0, };
2.
void reverse(char arr[])
{
	char	temp;
	int		len = strlen(arr);
	for(int idx = 0; idx < len/2; idx++)
	{
		temp = arr[idx];
		arr[idx] = arr[len - idx - 1];
		arr[len - idx - 1] = temp;
	}
}
3.
for(idx = 0; idx < len; idx++){
4.
		int sum = A[idx] - '0' + B[idx] - '0' + carry;
		if(sum < 0) sum += '0';
5.
		if(sum > 9)
			carry = 1;
		else
			carry = 0;
6.
		res[idx] = sum % 10 + '0';
	}
7.
	if(carry == 1)
		res[len] = '1';
8.	
	reverse(res);
9.	
	printf("%s", res);
	return 0;
}

```
* 정리
```
carry에 0을 주지않은 상태에서 돌리니까 틀린다... 왜? 계산 결과는 정상적으로 출력
```
## [9_1011.c]()
### [Fly me to the Alpha Centauri](https://www.acmicpc.net/problem/1011)
<img width="577" alt="스크린샷 2021-11-22 오후 5 16 44" src="https://user-images.githubusercontent.com/87407504/142826423-bee04749-60f3-44a0-889f-c5f6592a5dd1.png"><br>
* 핵심
```
처음과 끝의 이동은 1로 고정이다
이동 거리가 제곱의 값일 경우 가운데 새로운 값(+1)이 발생한다
제곱값을 기준으로 규칙을 찾는다
규칙 1 제곱값의 이동 횟수는 제곱근값 *2 -1
규칙 2 제곱값들간의 사이에 위치한 값을 반반 나누었을 때 반 이하의 값은 제일 가까운 제곱값의 이동 횟수 +1
규칙 3 반 이상의 값은 제일 가까운 제곱값의 이동횟수와 동일
```
* 문제접근
```
1.
규칙 1을 구현하기 위해 제곱근 값을 담을 변수를 설정
2.
x, y값의 범위가 2^31에 해당되므로 오버플로우를 고려한다
3.
제곱근값을 통해 세가지 경우의 수를 나누어 준다
```
* 코드구현
```.c
1.
#include <stdio.h>
#include <math.h>
int main(){
    int T, d;
    long long sq;
2.
    long long x, y;
    scanf("%d", &T);
    while(T--){
        scanf("%lld %lld", &x, &y);
        d = y - x;
        sq = sqrt(d);
3.
        if(d == sq * sq)
            printf("%d\n", sq*2 -1);
        else if(sq * sq < d && d <= sq * sq + sq)
            printf("%d\n", sq*2);
        else if(sq * sq + sq < d && d < (sq + 1)*(sq + 1))
            printf("%d\n", sq*2 + 1);
    }
    return 0;
}
```
* 정리
```
규칙찾기문제이다
규칙찾기가 매우 까다로운데 많은 문제를 풀어서 경우의수를 늘리자
범위의 문제가 발생할 것 같으면 long long 해버리자
longlong은 lld로 받는다
```
